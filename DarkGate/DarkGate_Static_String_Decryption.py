import sys , pefile , validators , re , base64
'''
Author: Mohamed Ashraf (@X__Junior)

Usage:
python3 darkgate.py path_to_sample
'''

def is_ascii(s):
    return all(ord(c) < 128 or ord(c) == 0 for c in s)

def extract_ip_address(content):
	ip_pattern = r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
	ip_addresses = []

	if type(content) is bytes:
		ip_pattern = rb'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'

	potential_ips = re.finditer(ip_pattern, content)

	for ip_bytes in potential_ips:
		ip_addresses.append(ip_bytes.group())

	return ip_addresses

def custom_decryption_2(encoded_string , key_expansion , xor_key , custom_alphabet):
	encoded_string = custom_base64_decode(encoded_string.decode(), custom_alphabet)
	decoded_str = ""

	for i in key_expansion:
		xor_key ^= i

	for char in encoded_string:
		decoded_str += chr( ( ~ (char ^ xor_key ) & 0xff) )

	return decoded_str


def custom_decryption(encoded_string , key_expansion , xor_key):
	encoded_string = base64.b64decode(encoded_string)
	decoded_str = ""

	for i in key_expansion:
		xor_key ^= i

	for char in encoded_string:
		decoded_str += chr( ( ~ (char ^ xor_key ) & 0xff) )

	return decoded_str


def custom_base64_decode(encoded_string , custom_alphabet):
	standard_table = str.maketrans(custom_alphabet, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")

	padding_needed = (4 - len(encoded_string) % 4) % 4
	encoded_string += custom_alphabet[0] * padding_needed

	standard_encoded_string = encoded_string.translate(standard_table)
	decoded_bytes = base64.b64decode(standard_encoded_string)

	return decoded_bytes



def main(args):
	file_data = open(binary_path,'rb').read()
	pe = pefile.PE(data=file_data)

	all_hardcoded_strings = []
	filterd_hardcoded_strings = []
	custom_alphabets = []
	potential_c2 = []

	for section in pe.sections:
		all_hardcoded_strings.extend(section.get_data().split(b'\x00'))

	for data in all_hardcoded_strings :
		try:
			if data != b'':
				if b'\xff' in data:
					filterd_hardcoded_strings.append(data.replace(b'\xff',b'').decode())
				else:
					filterd_hardcoded_strings.append(data.decode())
			if len(data) == 64 :
				custom_alphabets.append(data.decode())
			# extract domains if exists
			if validators.url(data.decode()):
						potential_c2.append(data)
		except:
			continue

	# Variant 1 , hash : 5b17e978c2ca2cf03e4ffff1e4609f2ec98738b1541fa41ba5b67f061e9e2af2
	for custom_alphabet in custom_alphabets:
		for data in filterd_hardcoded_strings:
			try:
				decoded_string = custom_base64_decode(data, custom_alphabet).decode().replace("\r\n", "")
				if is_ascii(decoded_string) and len(decoded_string) > 4:
					print(decoded_string)
				ip_addresses = extract_ip_address(decoded_string)
				for ip_address in ip_addresses:
					if validators.ip_address.ipv4(ip_address):
						potential_c2.append(ip_address)
				if validators.url(decoded_string):
					potential_c2.append(decoded_string)
			except:
				continue

	# Variant 2 , hash : 7ff58aca7eea812c1b0cde7f99ff8658502e76880375af72daef7b0deb63473c
	for i  in range(len(filterd_hardcoded_strings)-3):
		enc_data = filterd_hardcoded_strings[i]
		xor_byte = int.from_bytes(bytes(filterd_hardcoded_strings[i+1],"utf-8"),'little')
		xor_key = filterd_hardcoded_strings[i+2]

		if type(enc_data) is str and type(xor_byte) is int and type(xor_key) is str :
			try:
				decoded_string = custom_decryption(bytes(enc_data,"utf-8") , bytes(xor_key,"utf-8") , xor_byte).replace("\r\n", "")
				if is_ascii(decoded_string) and len(decoded_string) > 4:
						print(decoded_string)

				ip_addresses = extract_ip_address(decoded_string)
				for ip_address in ip_addresses:
					if validators.ip_address.ipv4(ip_address):
						potential_c2.append(ip_address)
				if validators.url(decoded_string):
					potential_c2.append(decoded_string)
			except:
				continue

	# Variant 3 , hash : da05617eded07cec14d283b73336c4582b4e812c99c81da14c06f28d7432e0f9
	for i  in range(len(filterd_hardcoded_strings)-2):
		enc_data = filterd_hardcoded_strings[i]
		xor_byte = int.from_bytes(bytes(filterd_hardcoded_strings[i+1],"utf-8"),'little')
		xor_key = filterd_hardcoded_strings[i+2]

		if type(enc_data) is str and type(xor_byte) is int and type(xor_key) is str :
			for custom_alphabet in custom_alphabets:
				try:
					decoded_string = custom_decryption_2(bytes(enc_data,"utf-8") , bytes(xor_key,"utf-8") , xor_byte , custom_alphabet).replace("\r\n", "")
					if is_ascii(decoded_string) and len(decoded_string) > 4:
							print(decoded_string)
					ip_addresses = extract_ip_address(decoded_string)
					for ip_address in ip_addresses:
						if validators.ip_address.ipv4(ip_address):
							potential_c2.append(ip_address)
					if validators.url(decoded_string):
						potential_c2.append(decoded_string)
				except:
					continue
	# Variant 4 , hash : efe4dd6e9ec7f3d60a456a863d47a1624ca5354bd37f8a3a7c7a4dd4f68596f4 , everything is hardcoded
	# extract hardcoded ip addresses if exist
	if potential_c2 == []:
		ip_addresses = extract_ip_address(file_data)
		for ip_address in ip_addresses:
			if validators.ip_address.ipv4(ip_address.decode()):
					potential_c2.append(ip_address.decode())
	print("Potential C2 : " , potential_c2  )

if __name__ == "__main__":
	binary_path = sys.argv[1]
	main(binary_path)